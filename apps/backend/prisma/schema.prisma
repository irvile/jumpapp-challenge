generator client {
    provider = "prisma-client-js"
    output   = "../src/libs/generated/prisma"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

model User {
    id                  String               @id
    name                String
    email               String
    emailVerified       Boolean              @default(false)
    image               String?
    createdAt           DateTime             @default(now())
    updatedAt           DateTime             @default(now()) @updatedAt
    sessions            Session[]
    accounts            Account[]
    calendarAccounts    CalendarAccount[]
    socialMediaAccounts SocialMediaAccount[]
    automations         Automation[]
    settings            UserSettings?
    stripeCustomer      StripeCustomer?

    @@unique([email])
    @@map("User")
}

model Session {
    id        String   @id
    expiresAt DateTime
    token     String
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    ipAddress String?
    userAgent String?
    userId    String
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([token])
    @@map("Session")
}

model Account {
    id                    String    @id
    accountId             String
    providerId            String
    userId                String
    user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    accessToken           String?
    refreshToken          String?
    idToken               String?
    accessTokenExpiresAt  DateTime?
    refreshTokenExpiresAt DateTime?
    scope                 String?
    password              String?
    createdAt             DateTime  @default(now())
    updatedAt             DateTime  @updatedAt

    @@map("Account")
}

model Verification {
    id         String   @id
    identifier String
    value      String
    expiresAt  DateTime
    createdAt  DateTime @default(now())
    updatedAt  DateTime @default(now()) @updatedAt

    @@map("verification")
}

model CalendarAccount {
    id             String          @id @default(cuid())
    provider       String          @default("GOOGLE")
    googleId       String
    email          String
    name           String
    accessToken    String
    refreshToken   String?
    expiresAt      DateTime?
    userId         String
    user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
    calendarEvents CalendarEvent[]
    createdAt      DateTime        @default(now())
    updatedAt      DateTime        @updatedAt

    @@unique([googleId])
}

model CalendarEvent {
    id              String          @id @default(cuid())
    externalId      String
    title           String
    description     String?
    startTime       DateTime
    endTime         DateTime
    meetingUrl      String?
    platform        Platform?
    attendees       String?
    location        String?
    googleAccountId String
    calendarAccount CalendarAccount @relation(fields: [googleAccountId], references: [id], onDelete: Cascade)
    bot             Bot?
    createdAt       DateTime        @default(now())
    updatedAt       DateTime        @updatedAt

    @@unique([externalId, googleAccountId])
}

model Bot {
    id              String        @id @default(cuid())
    provider        String        @default("RECALL")
    botId           String        @unique
    recallBotId     String?       @unique
    calendarEventId String        @unique
    calendarEvent   CalendarEvent @relation(fields: [calendarEventId], references: [id], onDelete: Cascade)
    status          BotStatus     @default(SCHEDULED)
    webhookReceived Boolean       @default(false)
    lastStatusCheck DateTime?
    joinedAt        DateTime?
    leftAt          DateTime?
    transcript      Transcript?
    createdAt       DateTime      @default(now())
    updatedAt       DateTime      @updatedAt
}

model Transcript {
    id                 String               @id @default(cuid())
    content            String
    rawContent         String?
    recallBotId        String               @unique
    recallBot          Bot                  @relation(fields: [recallBotId], references: [id], onDelete: Cascade)
    aiGeneratedContent AiGeneratedContent[]
    createdAt          DateTime             @default(now())
    updatedAt          DateTime             @updatedAt
}

model AiGeneratedContent {
    id              String           @id @default(cuid())
    type            ContentType
    title           String?
    content         String
    transcriptId    String
    transcript      Transcript       @relation(fields: [transcriptId], references: [id], onDelete: Cascade)
    automationId    String?
    automation      Automation?      @relation(fields: [automationId], references: [id])
    socialMediaPost SocialMediaPost?
    createdAt       DateTime         @default(now())
    updatedAt       DateTime         @updatedAt
}

model SocialMediaAccount {
    id               String            @id @default(cuid())
    platform         SocialPlatform
    externalId       String
    username         String
    displayName      String?
    accessToken      String
    refreshToken     String?
    expiresAt        DateTime?
    userId           String
    user             User              @relation(fields: [userId], references: [id], onDelete: Cascade)
    socialMediaPosts SocialMediaPost[]
    automations      Automation[]
    createdAt        DateTime          @default(now())
    updatedAt        DateTime          @updatedAt

    @@unique([platform, externalId])
}

model Automation {
    id                   String               @id @default(cuid())
    name                 String
    type                 AutomationType
    platform             SocialPlatform
    description          String
    example              String?
    contentType          ContentType
    isActive             Boolean              @default(true)
    userId               String
    user                 User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
    socialMediaAccountId String?
    socialMediaAccount   SocialMediaAccount?  @relation(fields: [socialMediaAccountId], references: [id], onDelete: Cascade)
    aiGeneratedContent   AiGeneratedContent[]
    createdAt            DateTime             @default(now())
    updatedAt            DateTime             @updatedAt
}

model SocialMediaPost {
    id                   String             @id @default(cuid())
    externalId           String?
    content              String
    publishedAt          DateTime?
    status               PostStatus         @default(DRAFT)
    socialMediaAccountId String
    socialMediaAccount   SocialMediaAccount @relation(fields: [socialMediaAccountId], references: [id], onDelete: Cascade)
    aiGeneratedContentId String             @unique
    aiGeneratedContent   AiGeneratedContent @relation(fields: [aiGeneratedContentId], references: [id], onDelete: Cascade)
    createdAt            DateTime           @default(now())
    updatedAt            DateTime           @updatedAt
}

model UserSettings {
    id                String   @id @default(cuid())
    joinMinutesBefore Int      @default(5)
    botName           String   @default("MeetPost AI")
    userId            String   @unique
    user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    createdAt         DateTime @default(now())
    updatedAt         DateTime @updatedAt
}

enum Platform {
    ZOOM
    GOOGLE_MEET
    MICROSOFT_TEAMS
}

enum BotStatus {
    SCHEDULED
    JOINING
    JOINED
    RECORDING
    COMPLETED
    FAILED
}

enum AutomationType {
    GENERATE_POST
    GENERATE_SUMMARY
}

enum ContentType {
    EMAIL
    LINKEDIN_POST
    FACEBOOK_POST
}

enum SocialPlatform {
    LINKEDIN
    FACEBOOK
}

enum PostStatus {
    DRAFT
    PUBLISHED
    FAILED
}

model StripeCustomer {
    id                String        @id @default(cuid())
    stripeCustomerId  String        @unique
    userId            String        @unique
    user              User          @relation(fields: [userId], references: [id], onDelete: Cascade)
    subscriptions     Subscription[]
    createdAt         DateTime      @default(now())
    updatedAt         DateTime      @updatedAt
}

model Subscription {
    id                   String             @id @default(cuid())
    stripeSubscriptionId String             @unique
    stripeCustomerId     String
    stripeCustomer       StripeCustomer     @relation(fields: [stripeCustomerId], references: [id], onDelete: Cascade)
    status               SubscriptionStatus
    currentPeriodStart   DateTime
    currentPeriodEnd     DateTime
    cancelAtPeriodEnd    Boolean            @default(false)
    canceledAt           DateTime?
    priceId              String
    productId            String
    metadata             Json?
    createdAt            DateTime           @default(now())
    updatedAt            DateTime           @updatedAt
}

enum SubscriptionStatus {
    ACTIVE
    CANCELED
    INCOMPLETE
    INCOMPLETE_EXPIRED
    PAST_DUE
    TRIALING
    UNPAID
}
